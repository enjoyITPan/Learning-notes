## GO 调度器----GPM模型

### 概念

go 程序通过调度器来调度Goroutine 在内核线程上执行，但是Goroutine并不直接跟系统线程绑定，而是通过Go调度器的Processor逻辑处理器来代理获取内核线程资源。整个go的调度器涉及三个资源：

1. Goroutine ：对应模型中的G，G是一个结构体，负责存储Goroutine的运行堆栈，状态以及任务函数。***可重用***。但是G并不能直接执行，必须绑定到一个P上，由P负责调度执行。

2. Processor：是Go中的逻辑处理器，由Go调度器负责维护。从Go的角度看，P就相当于Cpu，G需要绑定到P上进行调度。但是从系统角度看，P并非真实存在的线程，它需要绑定到M上才能执行，它主要为M提供执行环境(context)，比如内存分配状态，任务队列等。P存在的意义是为了解耦G和M，可以使少量的M支撑大量的G并发。

3. M：操作系统线程的抽象，是真正的任务执行单元。M获取到P之后会进入调度循环：从Global队列，P的local队列以及wait队列获取G进行执行。

   > P的数量由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。
   >
   > M数量不固定，由Go runtime 动态调整，最大不超过1万

### 工作窃取

当一个P队列的G全部执行完成后，Go将使用 工作窃取策略从别的地方获取可以执行的G：

从本地队列-> 全局队列 -> netpoll 网络事件 -> 其他P队列窃取一半

这样可以复用os线程，避免线程的上下文切换，也可以减少线程的销毁。

### 协程 阻塞调度

并发场景都避不开阻塞，那么当正在执行的Goroutine 阻塞了线程M怎么办？这个时候对应的P上的G还能被执行吗？

这个问题可以分为如下场景来看：

1. 场景一：由于原子、互斥量或者通道调用导致的G阻塞。

   > 调度器会将当前阻塞的G切换出去，重新调度P的local队列中的别的G。

2. 场景二：由于网络请求、IO操作导致的G阻塞。

   > 通过使用网络轮询器(netpoller)，调度器可以防止G进行这些系统调用时阻塞M。这样可以让M继续执行P中的其他G，而不需要创建新的M，可以减少系统级别的调度。
   >
   > netpoller：go 使用它来处理网络请求和IO，本身是io多路复用的实现。

3. 场景三：当执行一些系统调用导致阻塞

   > 除了netpoller，别的系统调用阻塞M时，调度器会将当前阻塞的M和G一起协调出去，脱离P队列。然后引入新的M继续执行P剩余的G

4. 场景四：G执行了sleep

   > 

## 抢占式调度

和操作系统按时间片调度线程不同，Go并没有时间片的概念。如果某个G没有进行system call调用、没有进行I/O操作、没有阻塞在一个channel操作上，那么**m是如何让G停下来并调度下一个runnable G的呢**？答案是：G是被抢占调度的。

除非极端的无限循环或死循环，否则只要G调用函数，Go runtime就有抢占G的机会。Go程序启动时，runtime会去启动一个名为sysmon的m(一般称为监控线程)，该m无需绑定p即可运行，该m在整个Go程序的运行过程中至关重要。

sysmon每20us~10ms启动一次，sysmon主要完成如下工作：

- 释放闲置超过5分钟的span物理内存；

- 如果超过2分钟没有垃圾回收，强制执行；

- 将长时间未处理的netpoll结果添加到任务队列；

- 向长时间运行的G任务发出抢占调度；

- 收回因syscall长时间阻塞的P

如果一个G任务运行10ms，sysmon就会认为其运行时间太久而发出抢占式调度的请求。一旦G的抢占标志位被设为true，那么待这个G下一次调用函数或方法时，runtime便可以将G抢占，并移出运行状态，放入P的local runq中，等待下一次被调度。



https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/

