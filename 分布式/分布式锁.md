## 一、为什么需要分布式锁

`锁`：

​        控制对资源的并发访问。具有互斥性。在java中一般是使用synchronized和ReentrantLock来实现对资源的互斥访问，但是前提是访问的线程在一个java进程中。在分布式场景下，同一个资源会被不同的服务器访问，这种情况下，java的锁就不起作用了。于是需要分布式锁来实现多进程、多主机服务互斥访问资源。

`举例`：

1. 假设有一个进程A，每小时准点给用户发送一条短信"Hello world"，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况；
2. 假设部署在两台机器，那么问题来了，用户每个小时就会收到两条"Hello world"，信息就重复了；
3. 我们希望只发送一条"Hello world"，那么就可以引入分布式锁的概念了；
4. 进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么B就放弃此次任务，等待下一个小时。

## 二、分布式锁的要求

- `安全性：`互斥，不管任何时候，只有一个客户端能持有同一个锁。

- `锁失效性：`不会死锁，最终一定会得到锁，就算一个持有锁的客户端宕掉或者发生网络分区。

- `容错性：`只要大多数锁节点正常工作，客户端应该都能获取和释放锁。
- `具备可重入特性：`线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，ReentrantLock和synchronized都是可重入锁；衍生到分布式环境中，一般仍然指的是线程的可重入，在绝大多数分布式环境中，都要求分布式锁是可重入的。
- `具备非阻塞锁特性:`即没有获取到锁将直接返回获取锁失败。

## 三、实现方案

### 3.1 基于数据库实现

### 3.2 基于redis实现

加锁：

```java
set key value nx px expireTime(毫秒) 
```

解锁：

```java
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```



### 该方案的问题在于

1) 通过过期时间来避免死锁，过期时间设置多长对业务来说往往比较头疼，时间短了可能会造成：持有锁的线程 A 任务还未处理完成，锁过期了，线程 B 获得了锁，导致同一个资源被 A、B 两个线程并发访问；时间长了会造成：持有锁的进程宕机，造成其他等待获取锁的进程长时间的无效等待

2) redis 的主从异步复制机制可能丢失数据，会出现如下场景：A 线程获得了锁，但锁数据还未同步到 slave 上，master 挂了，slave 顶成主，线程 B 尝试加锁，仍然能够成功，造成 A、B 两个线程并发访问同一个资源

### 3.3 基于zookeeper实现

ZooKeeper（以下简称“ZK”）中有一种节点叫做顺序节点，假如我们在/lock/目录下创建3个节点，ZK集群会按照发起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003。

ZK中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZK集群断开连接，则该节点自动被删除。EPHEMERAL_SEQUENTIAL为临时顺序节点。

根据ZK中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑： 

1. 客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。 
2. 客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。 
3. 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁。 
4. 如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。

释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可，不过也仍需要考虑删除节点失败等异常情况。

开源的基于ZK的Menagerie的源码就是一个典型的例子：https://github.com/sfines/menagerie 。

## 四、参考链接

[分布式系统互斥性与幂等性问题的分析与解决](https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html)
[Redis的分布式锁](https://redis.io/topics/distlock)
[翻译：用Redis构建分布式锁](http://ifeve.com/redis-lock/)

