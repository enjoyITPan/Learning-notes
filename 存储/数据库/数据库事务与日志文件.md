## 一、数据库事务

### 1. 什么是事务

> 数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：
>
> 1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
> 2. 当多个[应用程序](https://zh.wikipedia.org/wiki/应用程序)在[并发](https://zh.wikipedia.org/wiki/并发)访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
>
> 当事务被提交给了[数据库管理系统](https://zh.wikipedia.org/wiki/数据库管理系统)（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

### 2. 事务原理

2.1、原子性(atomic)：对数据库的一系列操作，要么全部执行成功，要么全部不执行。

2.2、隔离性(isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

2.3、一致性(consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。*一致状态*的含义是数据库中的数据应满足完整性约束。

2.4、持久性(durability)：已被提交的事务对数据库的修改应该永久保存在数据库中。

### 3. 事务测试

#### 	3.1 mysql事务介绍

| 事务隔离级别                | 脏读（如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了`脏读`） | 不可重复读（一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了`不可重复读`） | 幻读（一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了`幻读`） |
| :-------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 读未提交（read uncommit）   | 会                                                           | 会                                                           | 会                                                           |
| 读提交（read commit）       | 不会                                                         | 会                                                           | 会                                                           |
| 可重复读（repeatable read） | 不会                                                         | 不会                                                         | 会                                                           |
| 串行（serializable）        | 不会                                                         | 不会                                                         | 不会                                                         |

1、脏读：

<img src="https://gitee.com/nieyunshu/picture/raw/master/img/20211030144910.png" alt="image-20200815110931603" style="zoom:50%;" />

如上图，`Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务再去查询这条`number`为`1`的记录，如果读到列`name`的值为`'关羽'`，而`Session B`中的事务稍后进行了回滚，那么`Session A`中的事务相当于读到了一个不存在的数据，这种现象就称之为`脏读`。

2、不可重复读：

<img src="https://gitee.com/nieyunshu/picture/raw/master/img/20211030144927.png" alt="image-20200815111251762" style="zoom:50%;" />

如上图，我们在`Session B`中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了`number`列为`1`的记录的列`name`的值，每次事务提交之后，如果`Session A`中的事务都可以查看到最新的值，这种现象也被称之为`不可重复读`。

简言之：一个事务在自己的事务之中，可以不断读到别的事务已经修改的数据。

3、幻读：

<img src="https://gitee.com/nieyunshu/picture/raw/master/img/20211030144937.png" alt="image-20200815111608891" style="zoom:50%;" />

如上图，`Session A`中的事务先根据条件`number > 0`这个条件查询表`hero`，得到了`name`列值为`'刘备'`的记录；之后`Session B`中提交了一个隐式事务，该事务向表`hero`中插入了一条新记录；之后`Session A`中的事务再根据相同的条件`number > 0`查询表`hero`，得到的结果集中包含`Session B`中的事务新插入的那条记录，这种现象也被称之为`幻读`

#### 3.2、MVCC（仅在innodb中存在）

对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（`row_id`并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含`row_id`列）：

- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给`trx_id`隐藏列。

- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

对记录每次更新后，都会将旧值放到一条`undo日志`中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的`事务id`。

##### 3.2.1、ReadView

目的：ReadView主要是解决在`read commit`、`repeatable read`事务隔离级别下读取数据的准确性问题。

对于`READ UNCOMMITTED`隔离级别的事务来说，直接读取最新值就可以了；

对于`SERIALIZABLE`隔离级别的事务来说，通过加锁的方式读取值就可以了；

`ReadView`中主要包含4个比较重要的内容：

- `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。
- `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。
- `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。
- `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。

当访问数据时，mysql会按照下列步骤进行查询：

- 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

ReadView生成的时机：

`read commit`：

#### 每次读取数据前都生成一个ReadView

`repeatable read`：

#### 在第一次读取数据时生成一个ReadView



## 二、mysql log文件

### 1、redo log

***作用：***
　　确保事务的持久性，记录的是物理日志，即物理页上偏移量为多少的位置发生了什么变化。

　　防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
***内容：***
　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
***什么时候产生：***
　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
***什么时候释放：***
　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。

​       在同一个事务中，每当数据库进行修改时，将修改的结果更新到内存，然后在redo log添加一行记录记录“需要在哪个数据页上做什么修改”，并将该记录状态置为prepare，等到commit提交事务后，会将状态置为commit状态，之后将修改记录落盘时，会将redo log中状态为commit的记录全部写入磁盘。

### 2、undo log

作用：
　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

内容：
　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

什么时候产生：
　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性

什么时候释放：
　　当事务提交之后，undo log并不能立马被删除，
　　而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

### 3、binlog

作用：
　　1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
　　2，用于数据库的基于时间点的还原。
内容：
　　逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。
　　但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，
　　也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。
　　在使用mysqlbinlog解析binlog之后一切都会真相大白。
　　因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。

什么时候产生：
　　事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。
　　这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。
　　因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。
　　这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。

什么时候释放：
　　binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。

### 4、协做（两阶段提交）

![img](https://gitee.com/nieyunshu/picture/raw/master/img/20211030145012.jpeg)

### 5、update操作流程

```mysql
update T set c=c+1 where ID=2;
```

1、执行器先通过引擎查询到 id = 2 这行数据，id 是主键，直接遍历主键索引树直接插到这行数据，如果这行数据所在的数据页在内存中，就直接返回结果给执行器，否则，需要先从磁盘读入内存，然后再返回。

2、执行器拿到引擎给的行数据，把 这个值+1，得到新的一行数据，再调用引擎接口写入这行数据。

3、引擎将这行数据更新到内存中，同时记录到 redo log 中，此时 redo log 处于 perpare 状态，此时就告知执行器已经更新完成了，随时可以提交事务。

4、执行器生成这个操作的binlog，并把binlog写入磁盘

5、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成

如下图为 update 语句的执行流程，深色代表 MySQL 执行器中执行的，浅色代表 InnoDB 内部执行的。

<img src="https://gitee.com/nieyunshu/picture/raw/master/img/20211030162204.png" alt="image-20211030162204917" style="zoom:50%;" />

## 两阶段提交

写入 redo log 分为两个步骤，prepare 和 commit，这就是“两阶段提交”。

为什么要有两阶段提交，就是为了让 redo log 和 binlog 两个文件保持一致。我们还是用反证法来说明，假设没有两阶段提交会发生什么问题：

- 先写 redo log，再写 binlog，假设 redo log 写完，binlog 还没写完，MySQL 进程异常重启，redo log 写完后，即使系统崩溃，仍然能把数据恢复回来，所有恢复后的数据是正确的。但是 binlog 没写完，这时候 binlog 中就没有记录这条语句的操作，因此，之后备份日志的时候，binlog 就没有这条操作记录，如果用这个 binlog 来恢复临时库的话，由于这条语句记录的丢失，临时库就会少了这一个语句的操作，恢复出来的数据就与原库的值不同。
- 先写 binlog，再写 redo log，如果在 binlog 写完后系统崩溃了，由于 redo log 还没写，崩溃后这个事务无效，所以磁盘数据文件中的数据是没有这条语句的操作的，但是 binlog 中已经做了记录，所以以后用这个 binlog 来做数据恢复时，就多了一个事务操作，与原库的数据不一致。

如果没有“两阶段提交”，会导致 redo log 和 binlog 记录的操作不一致，那么数据库的状态就有可能和用它的日志恢复出来的库数据不一致。

所以，能够保证 redo log 和 binlog 的操作记录一致的流程是，将操作先更新到内存，再写入 redo log，此时标记为 prepare 状态，再写入 binlog，此时再提交事务，将 redo log 标记为 commit 状态。



## 三、参考资料
https://draveness.me/mysql-innodb

https://www.cnblogs.com/takumicx/p/9998844.html

https://blog.csdn.net/weixin_39198406/article/details/83069811

https://juejin.cn/post/6987557227074846733